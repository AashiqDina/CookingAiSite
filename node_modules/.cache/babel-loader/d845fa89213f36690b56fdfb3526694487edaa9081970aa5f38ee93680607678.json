{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name2 in all) __defProp(target, name2, {\n    get: all[name2],\n    enumerable: true\n  });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  textToVideo: () => textToVideo,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/config.ts\nvar HF_HUB_URL = \"https://huggingface.co\";\nvar HF_ROUTER_URL = \"https://router.huggingface.co\";\n\n// src/providers/fal-ai.ts\nvar FAL_AI_API_BASE_URL = \"https://fal.run\";\n\n// src/providers/nebius.ts\nvar NEBIUS_API_BASE_URL = \"https://api.studio.nebius.ai\";\n\n// src/providers/replicate.ts\nvar REPLICATE_API_BASE_URL = \"https://api.replicate.com\";\n\n// src/providers/sambanova.ts\nvar SAMBANOVA_API_BASE_URL = \"https://api.sambanova.ai\";\n\n// src/providers/together.ts\nvar TOGETHER_API_BASE_URL = \"https://api.together.xyz\";\n\n// src/providers/novita.ts\nvar NOVITA_API_BASE_URL = \"https://api.novita.ai/v3/openai\";\n\n// src/providers/fireworks-ai.ts\nvar FIREWORKS_AI_API_BASE_URL = \"https://api.fireworks.ai/inference\";\n\n// src/providers/hyperbolic.ts\nvar HYPERBOLIC_API_BASE_URL = \"https://api.hyperbolic.xyz\";\n\n// src/providers/black-forest-labs.ts\nvar BLACKFORESTLABS_AI_API_BASE_URL = \"https://api.us1.bfl.ai/v1\";\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// package.json\nvar name = \"@huggingface/inference\";\nvar version = \"3.3.6\";\n\n// src/providers/consts.ts\nvar HARDCODED_MODEL_ID_MAPPING = {\n  /**\n   * \"HF model ID\" => \"Model ID on Inference Provider's side\"\n   *\n   * Example:\n   * \"Qwen/Qwen2.5-Coder-32B-Instruct\": \"Qwen2.5-Coder-32B-Instruct\",\n   */\n  \"black-forest-labs\": {},\n  \"fal-ai\": {},\n  \"fireworks-ai\": {},\n  \"hf-inference\": {},\n  hyperbolic: {},\n  nebius: {},\n  replicate: {},\n  sambanova: {},\n  together: {},\n  novita: {}\n};\n\n// src/lib/getProviderModelId.ts\nvar inferenceProviderMappingCache = /* @__PURE__ */new Map();\nasync function getProviderModelId(params, args, options = {}) {\n  if (params.provider === \"hf-inference\") {\n    return params.model;\n  }\n  if (!options.taskHint) {\n    throw new Error(\"taskHint must be specified when using a third-party provider\");\n  }\n  const task = options.taskHint === \"text-generation\" && options.chatCompletion ? \"conversational\" : options.taskHint;\n  if (HARDCODED_MODEL_ID_MAPPING[params.provider]?.[params.model]) {\n    return HARDCODED_MODEL_ID_MAPPING[params.provider][params.model];\n  }\n  let inferenceProviderMapping;\n  if (inferenceProviderMappingCache.has(params.model)) {\n    inferenceProviderMapping = inferenceProviderMappingCache.get(params.model);\n  } else {\n    inferenceProviderMapping = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${params.model}?expand[]=inferenceProviderMapping`, {\n      headers: args.accessToken?.startsWith(\"hf_\") ? {\n        Authorization: `Bearer ${args.accessToken}`\n      } : {}\n    }).then(resp => resp.json()).then(json => json.inferenceProviderMapping).catch(() => null);\n  }\n  if (!inferenceProviderMapping) {\n    throw new Error(`We have not been able to find inference provider information for model ${params.model}.`);\n  }\n  const providerMapping = inferenceProviderMapping[params.provider];\n  if (providerMapping) {\n    if (providerMapping.task !== task) {\n      throw new Error(`Model ${params.model} is not supported for task ${task} and provider ${params.provider}. Supported task: ${providerMapping.task}.`);\n    }\n    if (providerMapping.status === \"staging\") {\n      console.warn(`Model ${params.model} is in staging mode for provider ${params.provider}. Meant for test purposes only.`);\n    }\n    return providerMapping.providerId;\n  }\n  throw new Error(`Model ${params.model} is not supported provider ${params.provider}.`);\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_HUB_INFERENCE_PROXY_TEMPLATE = `${HF_ROUTER_URL}/{{PROVIDER}}`;\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const {\n    accessToken,\n    endpointUrl,\n    provider: maybeProvider,\n    model: maybeModel,\n    ...remainingArgs\n  } = args;\n  let otherArgs = remainingArgs;\n  const provider = maybeProvider ?? \"hf-inference\";\n  const {\n    includeCredentials,\n    taskHint,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  if (endpointUrl && provider !== \"hf-inference\") {\n    throw new Error(`Cannot use endpointUrl with a third-party provider.`);\n  }\n  if (maybeModel && isUrl(maybeModel)) {\n    throw new Error(`Model URLs are no longer supported. Use endpointUrl instead.`);\n  }\n  if (!maybeModel && !taskHint) {\n    throw new Error(\"No model provided, and no task has been specified.\");\n  }\n  const hfModel = maybeModel ?? (await loadDefaultModel(taskHint));\n  const model = await getProviderModelId({\n    model: hfModel,\n    provider\n  }, args, {\n    taskHint,\n    chatCompletion: chatCompletion2,\n    fetch: options?.fetch\n  });\n  const authMethod = accessToken ? accessToken.startsWith(\"hf_\") ? \"hf-token\" : \"provider-key\" : includeCredentials === \"include\" ? \"credentials-include\" : \"none\";\n  const url = endpointUrl ? chatCompletion2 ? endpointUrl + `/v1/chat/completions` : endpointUrl : makeUrl({\n    authMethod,\n    chatCompletion: chatCompletion2 ?? false,\n    model,\n    provider: provider ?? \"hf-inference\",\n    taskHint\n  });\n  const headers = {};\n  if (accessToken) {\n    if (provider === \"fal-ai\" && authMethod === \"provider-key\") {\n      headers[\"Authorization\"] = `Key ${accessToken}`;\n    } else if (provider === \"black-forest-labs\" && authMethod === \"provider-key\") {\n      headers[\"X-Key\"] = accessToken;\n    } else {\n      headers[\"Authorization\"] = `Bearer ${accessToken}`;\n    }\n  }\n  const ownUserAgent = `${name}/${version}`;\n  headers[\"User-Agent\"] = [ownUserAgent, typeof navigator !== \"undefined\" ? navigator.userAgent : void 0].filter(x => x !== void 0).join(\" \");\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (provider === \"replicate\") {\n    headers[\"Prefer\"] = \"wait\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  if (provider === \"replicate\") {\n    const version2 = model.includes(\":\") ? model.split(\":\")[1] : void 0;\n    otherArgs = {\n      input: otherArgs,\n      version: version2\n    };\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs,\n      ...(taskHint === \"text-to-image\" && provider === \"hyperbolic\" ? {\n        model_name: model\n      } : chatCompletion2 || provider === \"together\" || provider === \"nebius\" || provider === \"hyperbolic\" ? {\n        model\n      } : void 0)\n    }),\n    ...(credentials ? {\n      credentials\n    } : void 0),\n    signal: options?.signal\n  };\n  return {\n    url,\n    info\n  };\n}\nfunction makeUrl(params) {\n  if (params.authMethod === \"none\" && params.provider !== \"hf-inference\") {\n    throw new Error(\"Authentication is required when requesting a third-party provider. Please provide accessToken\");\n  }\n  const shouldProxy = params.provider !== \"hf-inference\" && params.authMethod !== \"provider-key\";\n  switch (params.provider) {\n    case \"black-forest-labs\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : BLACKFORESTLABS_AI_API_BASE_URL;\n        return `${baseUrl}/${params.model}`;\n      }\n    case \"fal-ai\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : FAL_AI_API_BASE_URL;\n        return `${baseUrl}/${params.model}`;\n      }\n    case \"nebius\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : NEBIUS_API_BASE_URL;\n        if (params.taskHint === \"text-to-image\") {\n          return `${baseUrl}/v1/images/generations`;\n        }\n        if (params.taskHint === \"text-generation\") {\n          if (params.chatCompletion) {\n            return `${baseUrl}/v1/chat/completions`;\n          }\n          return `${baseUrl}/v1/completions`;\n        }\n        return baseUrl;\n      }\n    case \"replicate\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : REPLICATE_API_BASE_URL;\n        if (params.model.includes(\":\")) {\n          return `${baseUrl}/v1/predictions`;\n        }\n        return `${baseUrl}/v1/models/${params.model}/predictions`;\n      }\n    case \"sambanova\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : SAMBANOVA_API_BASE_URL;\n        if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n          return `${baseUrl}/v1/chat/completions`;\n        }\n        return baseUrl;\n      }\n    case \"together\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : TOGETHER_API_BASE_URL;\n        if (params.taskHint === \"text-to-image\") {\n          return `${baseUrl}/v1/images/generations`;\n        }\n        if (params.taskHint === \"text-generation\") {\n          if (params.chatCompletion) {\n            return `${baseUrl}/v1/chat/completions`;\n          }\n          return `${baseUrl}/v1/completions`;\n        }\n        return baseUrl;\n      }\n    case \"fireworks-ai\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : FIREWORKS_AI_API_BASE_URL;\n        if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n          return `${baseUrl}/v1/chat/completions`;\n        }\n        return baseUrl;\n      }\n    case \"hyperbolic\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : HYPERBOLIC_API_BASE_URL;\n        if (params.taskHint === \"text-to-image\") {\n          return `${baseUrl}/v1/images/generations`;\n        }\n        return `${baseUrl}/v1/chat/completions`;\n      }\n    case \"novita\":\n      {\n        const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : NOVITA_API_BASE_URL;\n        if (params.taskHint === \"text-generation\") {\n          if (params.chatCompletion) {\n            return `${baseUrl}/chat/completions`;\n          }\n          return `${baseUrl}/completions`;\n        }\n        return baseUrl;\n      }\n    default:\n      {\n        const baseUrl = HF_HUB_INFERENCE_PROXY_TEMPLATE.replaceAll(\"{{PROVIDER}}\", \"hf-inference\");\n        if (params.taskHint && [\"feature-extraction\", \"sentence-similarity\"].includes(params.taskHint)) {\n          return `${baseUrl}/pipeline/${params.taskHint}/${params.model}`;\n        }\n        if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n          return `${baseUrl}/models/${params.model}/v1/chat/completions`;\n        }\n        return `${baseUrl}/models/${params.model}`;\n      }\n  }\n}\nasync function loadDefaultModel(task) {\n  if (!tasks) {\n    tasks = await loadTaskInfo();\n  }\n  const taskInfo = tasks[task];\n  if ((taskInfo?.models.length ?? 0) <= 0) {\n    throw new Error(`No default model defined for task ${task}, please define the model explicitly.`);\n  }\n  return taskInfo.models[0].id;\n}\nasync function loadTaskInfo() {\n  const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n  if (!res.ok) {\n    throw new Error(\"Failed to load tasks definitions from Hugging Face Hub.\");\n  }\n  return await res.json();\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const {\n    url,\n    info\n  } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503) {\n    return request(args, options);\n  }\n  if (!response.ok) {\n    const contentType = response.headers.get(\"Content-Type\");\n    if ([\"application/json\", \"application/problem+json\"].some(ct => contentType?.startsWith(ct))) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${JSON.stringify(output.error)}`);\n      }\n      if (output.error || output.detail) {\n        throw new Error(JSON.stringify(output.error ?? output.detail));\n      } else {\n        throw new Error(output);\n      }\n    }\n    const message = contentType?.startsWith(\"text/plain;\") ? await response.text() : void 0;\n    throw new Error(message ?? \"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const {\n    url,\n    info\n  } = await makeRequestOptions({\n    ...args,\n    stream: true\n  }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503) {\n    return yield* streamingRequest(args, options);\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (typeof output.error === \"string\") {\n        throw new Error(output.error);\n      }\n      if (output.error && \"message\" in output.error && typeof output.error.message === \"string\") {\n        throw new Error(output.error.message);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(`Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\"));\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = event => {\n    events.push(event);\n  };\n  const onChunk = getLines(getMessages(() => {}, () => {}, onEvent));\n  try {\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        return;\n      }\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            const errorStr = typeof data.error === \"string\" ? data.error : typeof data.error === \"object\" && data.error && \"message\" in data.error && typeof data.error.message === \"string\" ? data.error.message : JSON.stringify(data.error);\n            throw new Error(`Error forwarded from backend: ` + errorStr);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(`Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`);\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign({}, ...props.map(prop => {\n    if (o[prop] !== void 0) {\n      return {\n        [prop]: o[prop]\n      };\n    }\n  }));\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter(prop => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/tasks/audio/utils.ts\nfunction preparePayload(args) {\n  return \"data\" in args ? args : {\n    ...omit(args, \"inputs\"),\n    data: args.inputs\n  };\n}\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const payload = preparePayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach(byte => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const payload = await buildPayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\nvar FAL_AI_SUPPORTED_BLOB_TYPES = [\"audio/mpeg\", \"audio/mp4\", \"audio/wav\", \"audio/x-wav\"];\nasync function buildPayload(args) {\n  if (args.provider === \"fal-ai\") {\n    const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : void 0;\n    const contentType = blob?.type;\n    if (!contentType) {\n      throw new Error(`Unable to determine the input's content-type. Make sure your are passing a Blob when using provider fal-ai.`);\n    }\n    if (!FAL_AI_SUPPORTED_BLOB_TYPES.includes(contentType)) {\n      throw new Error(`Provider fal-ai does not support blob type ${contentType} - supported content types are: ${FAL_AI_SUPPORTED_BLOB_TYPES.join(\", \")}`);\n    }\n    const base64audio = base64FromBytes(new Uint8Array(await blob.arrayBuffer()));\n    return {\n      ...(\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\")),\n      audio_url: `data:${contentType};base64,${base64audio}`\n    };\n  } else {\n    return preparePayload(args);\n  }\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const payload = args.provider === \"replicate\" ? {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    ...args.parameters,\n    text: args.inputs\n  } : args;\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  if (res instanceof Blob) {\n    return res;\n  }\n  if (res && typeof res === \"object\") {\n    if (\"output\" in res) {\n      if (typeof res.output === \"string\") {\n        const urlResponse = await fetch(res.output);\n        const blob = await urlResponse.blob();\n        return blob;\n      } else if (Array.isArray(res.output)) {\n        const urlResponse = await fetch(res.output[0]);\n        const blob = await urlResponse.blob();\n        return blob;\n      }\n    }\n  }\n  throw new InferenceOutputError(\"Expected Blob or object with output\");\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const payload = preparePayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  return validateOutput(res);\n}\nfunction validateOutput(output) {\n  if (!Array.isArray(output)) {\n    throw new InferenceOutputError(\"Expected Array\");\n  }\n  if (!output.every(elem => {\n    return typeof elem === \"object\" && elem && \"label\" in elem && typeof elem.label === \"string\" && \"content-type\" in elem && typeof elem[\"content-type\"] === \"string\" && \"blob\" in elem && typeof elem.blob === \"string\";\n  })) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, audio: Blob}>\");\n  }\n  return output;\n}\n\n// src/tasks/cv/utils.ts\nfunction preparePayload2(args) {\n  return \"data\" in args ? args : {\n    ...omit(args, \"inputs\"),\n    data: args.inputs\n  };\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const payload = preparePayload2(args);\n  const res = (await request(payload, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\");\n  }\n  return res;\n}\n\n// src/utils/delay.ts\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n// src/tasks/cv/textToImage.ts\nfunction getResponseFormatArg(provider) {\n  switch (provider) {\n    case \"fal-ai\":\n      return {\n        sync_mode: true\n      };\n    case \"nebius\":\n      return {\n        response_format: \"b64_json\"\n      };\n    case \"replicate\":\n      return void 0;\n    case \"together\":\n      return {\n        response_format: \"base64\"\n      };\n    default:\n      return void 0;\n  }\n}\nasync function textToImage(args, options) {\n  const payload = !args.provider || args.provider === \"hf-inference\" || args.provider === \"sambanova\" ? args : {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    ...args.parameters,\n    ...getResponseFormatArg(args.provider),\n    prompt: args.inputs\n  };\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  if (res && typeof res === \"object\") {\n    if (args.provider === \"black-forest-labs\" && \"polling_url\" in res && typeof res.polling_url === \"string\") {\n      return await pollBflResponse(res.polling_url, options?.outputType);\n    }\n    if (args.provider === \"fal-ai\" && \"images\" in res && Array.isArray(res.images) && res.images[0].url) {\n      if (options?.outputType === \"url\") {\n        return res.images[0].url;\n      } else {\n        const image = await fetch(res.images[0].url);\n        return await image.blob();\n      }\n    }\n    if (args.provider === \"hyperbolic\" && \"images\" in res && Array.isArray(res.images) && res.images[0] && typeof res.images[0].image === \"string\") {\n      if (options?.outputType === \"url\") {\n        return `data:image/jpeg;base64,${res.images[0].image}`;\n      }\n      const base64Response = await fetch(`data:image/jpeg;base64,${res.images[0].image}`);\n      return await base64Response.blob();\n    }\n    if (\"data\" in res && Array.isArray(res.data) && res.data[0].b64_json) {\n      const base64Data = res.data[0].b64_json;\n      if (options?.outputType === \"url\") {\n        return `data:image/jpeg;base64,${base64Data}`;\n      }\n      const base64Response = await fetch(`data:image/jpeg;base64,${base64Data}`);\n      return await base64Response.blob();\n    }\n    if (\"output\" in res && Array.isArray(res.output)) {\n      if (options?.outputType === \"url\") {\n        return res.output[0];\n      }\n      const urlResponse = await fetch(res.output[0]);\n      const blob = await urlResponse.blob();\n      return blob;\n    }\n  }\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  if (options?.outputType === \"url\") {\n    const b64 = await res.arrayBuffer().then(buf => Buffer.from(buf).toString(\"base64\"));\n    return `data:image/jpeg;base64,${b64}`;\n  }\n  return res;\n}\nasync function pollBflResponse(url, outputType) {\n  const urlObj = new URL(url);\n  for (let step = 0; step < 5; step++) {\n    await delay(1e3);\n    console.debug(`Polling Black Forest Labs API for the result... ${step + 1}/5`);\n    urlObj.searchParams.set(\"attempt\", step.toString(10));\n    const resp = await fetch(urlObj, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    if (!resp.ok) {\n      throw new InferenceOutputError(\"Failed to fetch result from black forest labs API\");\n    }\n    const payload = await resp.json();\n    if (typeof payload === \"object\" && payload && \"status\" in payload && typeof payload.status === \"string\" && payload.status === \"Ready\" && \"result\" in payload && typeof payload.result === \"object\" && payload.result && \"sample\" in payload.result && typeof payload.result.sample === \"string\") {\n      if (outputType === \"url\") {\n        return payload.result.sample;\n      }\n      const image = await fetch(payload.result.sample);\n      return await image.blob();\n    }\n  }\n  throw new InferenceOutputError(\"Failed to fetch result from black forest labs API\");\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function preparePayload3(args) {\n  if (args.inputs instanceof Blob) {\n    return {\n      ...args,\n      inputs: {\n        image: base64FromBytes(new Uint8Array(await args.inputs.arrayBuffer()))\n      }\n    };\n  } else {\n    return {\n      ...args,\n      inputs: {\n        image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n      }\n    };\n  }\n}\nasync function zeroShotImageClassification(args, options) {\n  const payload = await preparePayload3(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/textToVideo.ts\nvar SUPPORTED_PROVIDERS = [\"fal-ai\", \"replicate\"];\nasync function textToVideo(args, options) {\n  if (!args.provider || !typedInclude(SUPPORTED_PROVIDERS, args.provider)) {\n    throw new Error(`textToVideo inference is only supported for the following providers: ${SUPPORTED_PROVIDERS.join(\", \")}`);\n  }\n  const payload = args.provider === \"fal-ai\" || args.provider === \"replicate\" ? {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    ...args.parameters,\n    prompt: args.inputs\n  } : args;\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-video\"\n  });\n  if (args.provider === \"fal-ai\") {\n    const isValidOutput = typeof res === \"object\" && !!res && \"video\" in res && typeof res.video === \"object\" && !!res.video && \"url\" in res.video && typeof res.video.url === \"string\" && isUrl(res.video.url);\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected { video: { url: string } }\");\n    }\n    const urlResponse = await fetch(res.video.url);\n    return await urlResponse.blob();\n  } else {\n    const isValidOutput = typeof res === \"object\" && !!res && \"output\" in res && typeof res.output === \"string\" && isUrl(res.output);\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected { output: string }\");\n    }\n    const urlResponse = await fetch(res.output);\n    return await urlResponse.blob();\n  }\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\"\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth) return false;\n    if (arr.every(x => Array.isArray(x))) {\n      return arr.every(x => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every(x => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) ? res.every(elem => typeof elem === \"object\" && !!elem && typeof elem.answer === \"string\" && typeof elem.end === \"number\" && typeof elem.score === \"number\" && typeof elem.start === \"number\") : typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end: number, score: number, start: number}>\");\n  }\n  return Array.isArray(res) ? res[0] : res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const res = await request(prepareInput(args), {\n    ...options,\n    taskHint: \"sentence-similarity\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\nfunction prepareInput(args) {\n  return {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    inputs: {\n      ...omit(args.inputs, \"sourceSentence\")\n    },\n    parameters: {\n      source_sentence: args.inputs.sourceSentence,\n      ...args.parameters\n    }\n  };\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) ? res.every(elem => validate(elem)) : validate(res);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n  }\n  return Array.isArray(res) ? res[0] : res;\n}\nfunction validate(elem) {\n  return typeof elem === \"object\" && !!elem && \"aggregator\" in elem && typeof elem.aggregator === \"string\" && \"answer\" in elem && typeof elem.answer === \"string\" && \"cells\" in elem && Array.isArray(elem.cells) && elem.cells.every(x => typeof x === \"string\") && \"coordinates\" in elem && Array.isArray(elem.coordinates) && elem.coordinates.every(coord => Array.isArray(coord) && coord.every(x => typeof x === \"number\"));\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  if (args.provider === \"together\") {\n    args.prompt = args.inputs;\n    const raw = await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    });\n    const isValidOutput = typeof raw === \"object\" && \"choices\" in raw && Array.isArray(raw?.choices) && typeof raw?.model === \"string\";\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n    }\n    const completion = raw.choices[0];\n    return {\n      generated_text: completion.text\n    };\n  } else if (args.provider === \"hyperbolic\") {\n    const payload = {\n      messages: [{\n        content: args.inputs,\n        role: \"user\"\n      }],\n      ...(args.parameters ? {\n        max_tokens: args.parameters.max_new_tokens,\n        ...omit(args.parameters, \"max_new_tokens\")\n      } : void 0),\n      ...omit(args, [\"inputs\", \"parameters\"])\n    };\n    const raw = await request(payload, {\n      ...options,\n      taskHint: \"text-generation\"\n    });\n    const isValidOutput = typeof raw === \"object\" && \"choices\" in raw && Array.isArray(raw?.choices) && typeof raw?.model === \"string\";\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n    }\n    const completion = raw.choices[0];\n    return {\n      generated_text: completion.message.content\n    };\n  } else {\n    const res = toArray(await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    }));\n    const isValidOutput = Array.isArray(res) && res.every(x => \"generated_text\" in x && typeof x?.generated_text === \"string\");\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n    }\n    return res?.[0];\n  }\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"token-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"zero-shot-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => Array.isArray(x.labels) && x.labels.every(_label => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every(_score => typeof _score === \"number\") && typeof x.sequence === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && (\n  /// Together.ai and Nebius do not output a system_fingerprint\n  res.system_fingerprint === void 0 || res.system_fingerprint === null || typeof res.system_fingerprint === \"string\") && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = toArray(await request(reqArgs, {\n    ...options,\n    taskHint: \"document-question-answering\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(elem => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && (typeof elem.end === \"number\" || typeof elem.end === \"undefined\") && (typeof elem.score === \"number\" || typeof elem.score === \"undefined\") && (typeof elem.start === \"number\" || typeof elem.start === \"undefined\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res[0];\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(elem => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && typeof elem.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res[0];\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name2, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name2, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name2, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name2, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken,\n          endpointUrl\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n};\n\n// src/types.ts\nvar INFERENCE_PROVIDERS = [\"black-forest-labs\", \"fal-ai\", \"fireworks-ai\", \"hf-inference\", \"hyperbolic\", \"nebius\", \"novita\", \"replicate\", \"sambanova\", \"together\"];\nexport { HfInference, HfInferenceEndpoint, INFERENCE_PROVIDERS, InferenceOutputError, audioClassification, audioToAudio, automaticSpeechRecognition, chatCompletion, chatCompletionStream, documentQuestionAnswering, featureExtraction, fillMask, imageClassification, imageSegmentation, imageToImage, imageToText, objectDetection, questionAnswering, request, sentenceSimilarity, streamingRequest, summarization, tableQuestionAnswering, tabularClassification, tabularRegression, textClassification, textGeneration, textGenerationStream, textToImage, textToSpeech, textToVideo, tokenClassification, translation, visualQuestionAnswering, zeroShotClassification, zeroShotImageClassification };","map":{"version":3,"names":["__defProp","Object","defineProperty","__export","target","all","name2","get","enumerable","tasks_exports","audioClassification","audioToAudio","automaticSpeechRecognition","chatCompletion","chatCompletionStream","documentQuestionAnswering","featureExtraction","fillMask","imageClassification","imageSegmentation","imageToImage","imageToText","objectDetection","questionAnswering","request","sentenceSimilarity","streamingRequest","summarization","tableQuestionAnswering","tabularClassification","tabularRegression","textClassification","textGeneration","textGenerationStream","textToImage","textToSpeech","textToVideo","tokenClassification","translation","visualQuestionAnswering","zeroShotClassification","zeroShotImageClassification","HF_HUB_URL","HF_ROUTER_URL","FAL_AI_API_BASE_URL","NEBIUS_API_BASE_URL","REPLICATE_API_BASE_URL","SAMBANOVA_API_BASE_URL","TOGETHER_API_BASE_URL","NOVITA_API_BASE_URL","FIREWORKS_AI_API_BASE_URL","HYPERBOLIC_API_BASE_URL","BLACKFORESTLABS_AI_API_BASE_URL","isUrl","modelOrUrl","test","startsWith","name","version","HARDCODED_MODEL_ID_MAPPING","hyperbolic","nebius","replicate","sambanova","together","novita","inferenceProviderMappingCache","Map","getProviderModelId","params","args","options","provider","model","taskHint","Error","task","inferenceProviderMapping","has","fetch","headers","accessToken","Authorization","then","resp","json","catch","providerMapping","status","console","warn","providerId","HF_HUB_INFERENCE_PROXY_TEMPLATE","tasks","makeRequestOptions","endpointUrl","maybeProvider","maybeModel","remainingArgs","otherArgs","includeCredentials","chatCompletion2","hfModel","loadDefaultModel","authMethod","url","makeUrl","ownUserAgent","navigator","userAgent","filter","x","join","binary","data","credentials","version2","includes","split","input","info","method","body","JSON","stringify","model_name","signal","shouldProxy","baseUrl","replace","replaceAll","loadTaskInfo","taskInfo","models","length","id","res","ok","response","retry_on_error","contentType","some","ct","output","error","detail","message","text","blob","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","onChunk","arr","concat","bufLength","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","value","event","retry","parseInt","isNaN","a","b","Uint8Array","set","stream","reader","getReader","events","onEvent","push","done","read","parse","errorStr","releaseLock","InferenceOutputError","TypeError","constructor","pick","o","props","assign","map","prop","typedInclude","v","omit","propsArr","Array","isArray","letsKeep","keys","preparePayload","inputs","payload","isValidOutput","every","label","score","base64FromBytes","globalThis","Buffer","from","toString","bin","forEach","byte","String","fromCharCode","btoa","buildPayload","FAL_AI_SUPPORTED_BLOB_TYPES","Blob","type","base64audio","arrayBuffer","audio_url","parameters","urlResponse","validateOutput","elem","preparePayload2","mask","generated_text","box","xmin","ymin","xmax","ymax","delay","ms","Promise","resolve","setTimeout","getResponseFormatArg","sync_mode","response_format","prompt","polling_url","pollBflResponse","outputType","images","image","base64Response","b64_json","base64Data","b64","buf","urlObj","URL","step","debug","searchParams","result","sample","reqArgs","ArrayBuffer","preparePayload3","SUPPORTED_PROVIDERS","video","isNumArrayRec","maxDepth","curDepth","sequence","token","token_str","answer","end","start","prepareInput","source_sentence","sourceSentence","summary_text","validate","aggregator","cells","coordinates","coord","toArray","obj","raw","choices","completion","messages","content","role","max_tokens","max_new_tokens","entity_group","word","translation_text","labels","_label","scores","_score","created","system_fingerprint","usage","question","HfInference","defaultOptions","fn","entries","endpoint","HfInferenceEndpoint","INFERENCE_PROVIDERS"],"sources":["/Users/Aashiq/Desktop/Projects/CookingAiSite/node_modules/@huggingface/inference/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  textToVideo: () => textToVideo,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/config.ts\nvar HF_HUB_URL = \"https://huggingface.co\";\nvar HF_ROUTER_URL = \"https://router.huggingface.co\";\n\n// src/providers/fal-ai.ts\nvar FAL_AI_API_BASE_URL = \"https://fal.run\";\n\n// src/providers/nebius.ts\nvar NEBIUS_API_BASE_URL = \"https://api.studio.nebius.ai\";\n\n// src/providers/replicate.ts\nvar REPLICATE_API_BASE_URL = \"https://api.replicate.com\";\n\n// src/providers/sambanova.ts\nvar SAMBANOVA_API_BASE_URL = \"https://api.sambanova.ai\";\n\n// src/providers/together.ts\nvar TOGETHER_API_BASE_URL = \"https://api.together.xyz\";\n\n// src/providers/novita.ts\nvar NOVITA_API_BASE_URL = \"https://api.novita.ai/v3/openai\";\n\n// src/providers/fireworks-ai.ts\nvar FIREWORKS_AI_API_BASE_URL = \"https://api.fireworks.ai/inference\";\n\n// src/providers/hyperbolic.ts\nvar HYPERBOLIC_API_BASE_URL = \"https://api.hyperbolic.xyz\";\n\n// src/providers/black-forest-labs.ts\nvar BLACKFORESTLABS_AI_API_BASE_URL = \"https://api.us1.bfl.ai/v1\";\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// package.json\nvar name = \"@huggingface/inference\";\nvar version = \"3.3.6\";\n\n// src/providers/consts.ts\nvar HARDCODED_MODEL_ID_MAPPING = {\n  /**\n   * \"HF model ID\" => \"Model ID on Inference Provider's side\"\n   *\n   * Example:\n   * \"Qwen/Qwen2.5-Coder-32B-Instruct\": \"Qwen2.5-Coder-32B-Instruct\",\n   */\n  \"black-forest-labs\": {},\n  \"fal-ai\": {},\n  \"fireworks-ai\": {},\n  \"hf-inference\": {},\n  hyperbolic: {},\n  nebius: {},\n  replicate: {},\n  sambanova: {},\n  together: {},\n  novita: {}\n};\n\n// src/lib/getProviderModelId.ts\nvar inferenceProviderMappingCache = /* @__PURE__ */ new Map();\nasync function getProviderModelId(params, args, options = {}) {\n  if (params.provider === \"hf-inference\") {\n    return params.model;\n  }\n  if (!options.taskHint) {\n    throw new Error(\"taskHint must be specified when using a third-party provider\");\n  }\n  const task = options.taskHint === \"text-generation\" && options.chatCompletion ? \"conversational\" : options.taskHint;\n  if (HARDCODED_MODEL_ID_MAPPING[params.provider]?.[params.model]) {\n    return HARDCODED_MODEL_ID_MAPPING[params.provider][params.model];\n  }\n  let inferenceProviderMapping;\n  if (inferenceProviderMappingCache.has(params.model)) {\n    inferenceProviderMapping = inferenceProviderMappingCache.get(params.model);\n  } else {\n    inferenceProviderMapping = await (options?.fetch ?? fetch)(\n      `${HF_HUB_URL}/api/models/${params.model}?expand[]=inferenceProviderMapping`,\n      {\n        headers: args.accessToken?.startsWith(\"hf_\") ? { Authorization: `Bearer ${args.accessToken}` } : {}\n      }\n    ).then((resp) => resp.json()).then((json) => json.inferenceProviderMapping).catch(() => null);\n  }\n  if (!inferenceProviderMapping) {\n    throw new Error(`We have not been able to find inference provider information for model ${params.model}.`);\n  }\n  const providerMapping = inferenceProviderMapping[params.provider];\n  if (providerMapping) {\n    if (providerMapping.task !== task) {\n      throw new Error(\n        `Model ${params.model} is not supported for task ${task} and provider ${params.provider}. Supported task: ${providerMapping.task}.`\n      );\n    }\n    if (providerMapping.status === \"staging\") {\n      console.warn(\n        `Model ${params.model} is in staging mode for provider ${params.provider}. Meant for test purposes only.`\n      );\n    }\n    return providerMapping.providerId;\n  }\n  throw new Error(`Model ${params.model} is not supported provider ${params.provider}.`);\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_HUB_INFERENCE_PROXY_TEMPLATE = `${HF_ROUTER_URL}/{{PROVIDER}}`;\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, provider: maybeProvider, model: maybeModel, ...remainingArgs } = args;\n  let otherArgs = remainingArgs;\n  const provider = maybeProvider ?? \"hf-inference\";\n  const { includeCredentials, taskHint, chatCompletion: chatCompletion2 } = options ?? {};\n  if (endpointUrl && provider !== \"hf-inference\") {\n    throw new Error(`Cannot use endpointUrl with a third-party provider.`);\n  }\n  if (maybeModel && isUrl(maybeModel)) {\n    throw new Error(`Model URLs are no longer supported. Use endpointUrl instead.`);\n  }\n  if (!maybeModel && !taskHint) {\n    throw new Error(\"No model provided, and no task has been specified.\");\n  }\n  const hfModel = maybeModel ?? await loadDefaultModel(taskHint);\n  const model = await getProviderModelId({ model: hfModel, provider }, args, {\n    taskHint,\n    chatCompletion: chatCompletion2,\n    fetch: options?.fetch\n  });\n  const authMethod = accessToken ? accessToken.startsWith(\"hf_\") ? \"hf-token\" : \"provider-key\" : includeCredentials === \"include\" ? \"credentials-include\" : \"none\";\n  const url = endpointUrl ? chatCompletion2 ? endpointUrl + `/v1/chat/completions` : endpointUrl : makeUrl({\n    authMethod,\n    chatCompletion: chatCompletion2 ?? false,\n    model,\n    provider: provider ?? \"hf-inference\",\n    taskHint\n  });\n  const headers = {};\n  if (accessToken) {\n    if (provider === \"fal-ai\" && authMethod === \"provider-key\") {\n      headers[\"Authorization\"] = `Key ${accessToken}`;\n    } else if (provider === \"black-forest-labs\" && authMethod === \"provider-key\") {\n      headers[\"X-Key\"] = accessToken;\n    } else {\n      headers[\"Authorization\"] = `Bearer ${accessToken}`;\n    }\n  }\n  const ownUserAgent = `${name}/${version}`;\n  headers[\"User-Agent\"] = [ownUserAgent, typeof navigator !== \"undefined\" ? navigator.userAgent : void 0].filter((x) => x !== void 0).join(\" \");\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (provider === \"replicate\") {\n    headers[\"Prefer\"] = \"wait\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  if (provider === \"replicate\") {\n    const version2 = model.includes(\":\") ? model.split(\":\")[1] : void 0;\n    otherArgs = { input: otherArgs, version: version2 };\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs,\n      ...taskHint === \"text-to-image\" && provider === \"hyperbolic\" ? { model_name: model } : chatCompletion2 || provider === \"together\" || provider === \"nebius\" || provider === \"hyperbolic\" ? { model } : void 0\n    }),\n    ...credentials ? { credentials } : void 0,\n    signal: options?.signal\n  };\n  return { url, info };\n}\nfunction makeUrl(params) {\n  if (params.authMethod === \"none\" && params.provider !== \"hf-inference\") {\n    throw new Error(\"Authentication is required when requesting a third-party provider. Please provide accessToken\");\n  }\n  const shouldProxy = params.provider !== \"hf-inference\" && params.authMethod !== \"provider-key\";\n  switch (params.provider) {\n    case \"black-forest-labs\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : BLACKFORESTLABS_AI_API_BASE_URL;\n      return `${baseUrl}/${params.model}`;\n    }\n    case \"fal-ai\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : FAL_AI_API_BASE_URL;\n      return `${baseUrl}/${params.model}`;\n    }\n    case \"nebius\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : NEBIUS_API_BASE_URL;\n      if (params.taskHint === \"text-to-image\") {\n        return `${baseUrl}/v1/images/generations`;\n      }\n      if (params.taskHint === \"text-generation\") {\n        if (params.chatCompletion) {\n          return `${baseUrl}/v1/chat/completions`;\n        }\n        return `${baseUrl}/v1/completions`;\n      }\n      return baseUrl;\n    }\n    case \"replicate\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : REPLICATE_API_BASE_URL;\n      if (params.model.includes(\":\")) {\n        return `${baseUrl}/v1/predictions`;\n      }\n      return `${baseUrl}/v1/models/${params.model}/predictions`;\n    }\n    case \"sambanova\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : SAMBANOVA_API_BASE_URL;\n      if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n        return `${baseUrl}/v1/chat/completions`;\n      }\n      return baseUrl;\n    }\n    case \"together\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : TOGETHER_API_BASE_URL;\n      if (params.taskHint === \"text-to-image\") {\n        return `${baseUrl}/v1/images/generations`;\n      }\n      if (params.taskHint === \"text-generation\") {\n        if (params.chatCompletion) {\n          return `${baseUrl}/v1/chat/completions`;\n        }\n        return `${baseUrl}/v1/completions`;\n      }\n      return baseUrl;\n    }\n    case \"fireworks-ai\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : FIREWORKS_AI_API_BASE_URL;\n      if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n        return `${baseUrl}/v1/chat/completions`;\n      }\n      return baseUrl;\n    }\n    case \"hyperbolic\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : HYPERBOLIC_API_BASE_URL;\n      if (params.taskHint === \"text-to-image\") {\n        return `${baseUrl}/v1/images/generations`;\n      }\n      return `${baseUrl}/v1/chat/completions`;\n    }\n    case \"novita\": {\n      const baseUrl = shouldProxy ? HF_HUB_INFERENCE_PROXY_TEMPLATE.replace(\"{{PROVIDER}}\", params.provider) : NOVITA_API_BASE_URL;\n      if (params.taskHint === \"text-generation\") {\n        if (params.chatCompletion) {\n          return `${baseUrl}/chat/completions`;\n        }\n        return `${baseUrl}/completions`;\n      }\n      return baseUrl;\n    }\n    default: {\n      const baseUrl = HF_HUB_INFERENCE_PROXY_TEMPLATE.replaceAll(\"{{PROVIDER}}\", \"hf-inference\");\n      if (params.taskHint && [\"feature-extraction\", \"sentence-similarity\"].includes(params.taskHint)) {\n        return `${baseUrl}/pipeline/${params.taskHint}/${params.model}`;\n      }\n      if (params.taskHint === \"text-generation\" && params.chatCompletion) {\n        return `${baseUrl}/models/${params.model}/v1/chat/completions`;\n      }\n      return `${baseUrl}/models/${params.model}`;\n    }\n  }\n}\nasync function loadDefaultModel(task) {\n  if (!tasks) {\n    tasks = await loadTaskInfo();\n  }\n  const taskInfo = tasks[task];\n  if ((taskInfo?.models.length ?? 0) <= 0) {\n    throw new Error(`No default model defined for task ${task}, please define the model explicitly.`);\n  }\n  return taskInfo.models[0].id;\n}\nasync function loadTaskInfo() {\n  const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n  if (!res.ok) {\n    throw new Error(\"Failed to load tasks definitions from Hugging Face Hub.\");\n  }\n  return await res.json();\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503) {\n    return request(args, options);\n  }\n  if (!response.ok) {\n    const contentType = response.headers.get(\"Content-Type\");\n    if ([\"application/json\", \"application/problem+json\"].some((ct) => contentType?.startsWith(ct))) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(\n          `Server ${args.model} does not seem to support chat completion. Error: ${JSON.stringify(output.error)}`\n        );\n      }\n      if (output.error || output.detail) {\n        throw new Error(JSON.stringify(output.error ?? output.detail));\n      } else {\n        throw new Error(output);\n      }\n    }\n    const message = contentType?.startsWith(\"text/plain;\") ? await response.text() : void 0;\n    throw new Error(message ?? \"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503) {\n    return yield* streamingRequest(args, options);\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (typeof output.error === \"string\") {\n        throw new Error(output.error);\n      }\n      if (output.error && \"message\" in output.error && typeof output.error.message === \"string\") {\n        throw new Error(output.error.message);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            const errorStr = typeof data.error === \"string\" ? data.error : typeof data.error === \"object\" && data.error && \"message\" in data.error && typeof data.error.message === \"string\" ? data.error.message : JSON.stringify(data.error);\n            throw new Error(`Error forwarded from backend: ` + errorStr);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/tasks/audio/utils.ts\nfunction preparePayload(args) {\n  return \"data\" in args ? args : {\n    ...omit(args, \"inputs\"),\n    data: args.inputs\n  };\n}\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const payload = preparePayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const payload = await buildPayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\nvar FAL_AI_SUPPORTED_BLOB_TYPES = [\"audio/mpeg\", \"audio/mp4\", \"audio/wav\", \"audio/x-wav\"];\nasync function buildPayload(args) {\n  if (args.provider === \"fal-ai\") {\n    const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : void 0;\n    const contentType = blob?.type;\n    if (!contentType) {\n      throw new Error(\n        `Unable to determine the input's content-type. Make sure your are passing a Blob when using provider fal-ai.`\n      );\n    }\n    if (!FAL_AI_SUPPORTED_BLOB_TYPES.includes(contentType)) {\n      throw new Error(\n        `Provider fal-ai does not support blob type ${contentType} - supported content types are: ${FAL_AI_SUPPORTED_BLOB_TYPES.join(\n          \", \"\n        )}`\n      );\n    }\n    const base64audio = base64FromBytes(new Uint8Array(await blob.arrayBuffer()));\n    return {\n      ...\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\"),\n      audio_url: `data:${contentType};base64,${base64audio}`\n    };\n  } else {\n    return preparePayload(args);\n  }\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const payload = args.provider === \"replicate\" ? {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    ...args.parameters,\n    text: args.inputs\n  } : args;\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  if (res instanceof Blob) {\n    return res;\n  }\n  if (res && typeof res === \"object\") {\n    if (\"output\" in res) {\n      if (typeof res.output === \"string\") {\n        const urlResponse = await fetch(res.output);\n        const blob = await urlResponse.blob();\n        return blob;\n      } else if (Array.isArray(res.output)) {\n        const urlResponse = await fetch(res.output[0]);\n        const blob = await urlResponse.blob();\n        return blob;\n      }\n    }\n  }\n  throw new InferenceOutputError(\"Expected Blob or object with output\");\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const payload = preparePayload(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  return validateOutput(res);\n}\nfunction validateOutput(output) {\n  if (!Array.isArray(output)) {\n    throw new InferenceOutputError(\"Expected Array\");\n  }\n  if (!output.every((elem) => {\n    return typeof elem === \"object\" && elem && \"label\" in elem && typeof elem.label === \"string\" && \"content-type\" in elem && typeof elem[\"content-type\"] === \"string\" && \"blob\" in elem && typeof elem.blob === \"string\";\n  })) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, audio: Blob}>\");\n  }\n  return output;\n}\n\n// src/tasks/cv/utils.ts\nfunction preparePayload2(args) {\n  return \"data\" in args ? args : { ...omit(args, \"inputs\"), data: args.inputs };\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const payload = preparePayload2(args);\n  const res = (await request(payload, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const payload = preparePayload2(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/utils/delay.ts\nfunction delay(ms) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n// src/tasks/cv/textToImage.ts\nfunction getResponseFormatArg(provider) {\n  switch (provider) {\n    case \"fal-ai\":\n      return { sync_mode: true };\n    case \"nebius\":\n      return { response_format: \"b64_json\" };\n    case \"replicate\":\n      return void 0;\n    case \"together\":\n      return { response_format: \"base64\" };\n    default:\n      return void 0;\n  }\n}\nasync function textToImage(args, options) {\n  const payload = !args.provider || args.provider === \"hf-inference\" || args.provider === \"sambanova\" ? args : {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    ...args.parameters,\n    ...getResponseFormatArg(args.provider),\n    prompt: args.inputs\n  };\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  if (res && typeof res === \"object\") {\n    if (args.provider === \"black-forest-labs\" && \"polling_url\" in res && typeof res.polling_url === \"string\") {\n      return await pollBflResponse(res.polling_url, options?.outputType);\n    }\n    if (args.provider === \"fal-ai\" && \"images\" in res && Array.isArray(res.images) && res.images[0].url) {\n      if (options?.outputType === \"url\") {\n        return res.images[0].url;\n      } else {\n        const image = await fetch(res.images[0].url);\n        return await image.blob();\n      }\n    }\n    if (args.provider === \"hyperbolic\" && \"images\" in res && Array.isArray(res.images) && res.images[0] && typeof res.images[0].image === \"string\") {\n      if (options?.outputType === \"url\") {\n        return `data:image/jpeg;base64,${res.images[0].image}`;\n      }\n      const base64Response = await fetch(`data:image/jpeg;base64,${res.images[0].image}`);\n      return await base64Response.blob();\n    }\n    if (\"data\" in res && Array.isArray(res.data) && res.data[0].b64_json) {\n      const base64Data = res.data[0].b64_json;\n      if (options?.outputType === \"url\") {\n        return `data:image/jpeg;base64,${base64Data}`;\n      }\n      const base64Response = await fetch(`data:image/jpeg;base64,${base64Data}`);\n      return await base64Response.blob();\n    }\n    if (\"output\" in res && Array.isArray(res.output)) {\n      if (options?.outputType === \"url\") {\n        return res.output[0];\n      }\n      const urlResponse = await fetch(res.output[0]);\n      const blob = await urlResponse.blob();\n      return blob;\n    }\n  }\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  if (options?.outputType === \"url\") {\n    const b64 = await res.arrayBuffer().then((buf) => Buffer.from(buf).toString(\"base64\"));\n    return `data:image/jpeg;base64,${b64}`;\n  }\n  return res;\n}\nasync function pollBflResponse(url, outputType) {\n  const urlObj = new URL(url);\n  for (let step = 0; step < 5; step++) {\n    await delay(1e3);\n    console.debug(`Polling Black Forest Labs API for the result... ${step + 1}/5`);\n    urlObj.searchParams.set(\"attempt\", step.toString(10));\n    const resp = await fetch(urlObj, { headers: { \"Content-Type\": \"application/json\" } });\n    if (!resp.ok) {\n      throw new InferenceOutputError(\"Failed to fetch result from black forest labs API\");\n    }\n    const payload = await resp.json();\n    if (typeof payload === \"object\" && payload && \"status\" in payload && typeof payload.status === \"string\" && payload.status === \"Ready\" && \"result\" in payload && typeof payload.result === \"object\" && payload.result && \"sample\" in payload.result && typeof payload.result.sample === \"string\") {\n      if (outputType === \"url\") {\n        return payload.result.sample;\n      }\n      const image = await fetch(payload.result.sample);\n      return await image.blob();\n    }\n  }\n  throw new InferenceOutputError(\"Failed to fetch result from black forest labs API\");\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function preparePayload3(args) {\n  if (args.inputs instanceof Blob) {\n    return {\n      ...args,\n      inputs: {\n        image: base64FromBytes(new Uint8Array(await args.inputs.arrayBuffer()))\n      }\n    };\n  } else {\n    return {\n      ...args,\n      inputs: {\n        image: base64FromBytes(\n          new Uint8Array(\n            args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n          )\n        )\n      }\n    };\n  }\n}\nasync function zeroShotImageClassification(args, options) {\n  const payload = await preparePayload3(args);\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/textToVideo.ts\nvar SUPPORTED_PROVIDERS = [\"fal-ai\", \"replicate\"];\nasync function textToVideo(args, options) {\n  if (!args.provider || !typedInclude(SUPPORTED_PROVIDERS, args.provider)) {\n    throw new Error(\n      `textToVideo inference is only supported for the following providers: ${SUPPORTED_PROVIDERS.join(\", \")}`\n    );\n  }\n  const payload = args.provider === \"fal-ai\" || args.provider === \"replicate\" ? { ...omit(args, [\"inputs\", \"parameters\"]), ...args.parameters, prompt: args.inputs } : args;\n  const res = await request(payload, {\n    ...options,\n    taskHint: \"text-to-video\"\n  });\n  if (args.provider === \"fal-ai\") {\n    const isValidOutput = typeof res === \"object\" && !!res && \"video\" in res && typeof res.video === \"object\" && !!res.video && \"url\" in res.video && typeof res.video.url === \"string\" && isUrl(res.video.url);\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected { video: { url: string } }\");\n    }\n    const urlResponse = await fetch(res.video.url);\n    return await urlResponse.blob();\n  } else {\n    const isValidOutput = typeof res === \"object\" && !!res && \"output\" in res && typeof res.output === \"string\" && isUrl(res.output);\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected { output: string }\");\n    }\n    const urlResponse = await fetch(res.output);\n    return await urlResponse.blob();\n  }\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\"\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) ? res.every(\n    (elem) => typeof elem === \"object\" && !!elem && typeof elem.answer === \"string\" && typeof elem.end === \"number\" && typeof elem.score === \"number\" && typeof elem.start === \"number\"\n  ) : typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end: number, score: number, start: number}>\");\n  }\n  return Array.isArray(res) ? res[0] : res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const res = await request(prepareInput(args), {\n    ...options,\n    taskHint: \"sentence-similarity\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\nfunction prepareInput(args) {\n  return {\n    ...omit(args, [\"inputs\", \"parameters\"]),\n    inputs: { ...omit(args.inputs, \"sourceSentence\") },\n    parameters: { source_sentence: args.inputs.sourceSentence, ...args.parameters }\n  };\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) ? res.every((elem) => validate(elem)) : validate(res);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return Array.isArray(res) ? res[0] : res;\n}\nfunction validate(elem) {\n  return typeof elem === \"object\" && !!elem && \"aggregator\" in elem && typeof elem.aggregator === \"string\" && \"answer\" in elem && typeof elem.answer === \"string\" && \"cells\" in elem && Array.isArray(elem.cells) && elem.cells.every((x) => typeof x === \"string\") && \"coordinates\" in elem && Array.isArray(elem.coordinates) && elem.coordinates.every(\n    (coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\")\n  );\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  if (args.provider === \"together\") {\n    args.prompt = args.inputs;\n    const raw = await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    });\n    const isValidOutput = typeof raw === \"object\" && \"choices\" in raw && Array.isArray(raw?.choices) && typeof raw?.model === \"string\";\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n    }\n    const completion = raw.choices[0];\n    return {\n      generated_text: completion.text\n    };\n  } else if (args.provider === \"hyperbolic\") {\n    const payload = {\n      messages: [{ content: args.inputs, role: \"user\" }],\n      ...args.parameters ? {\n        max_tokens: args.parameters.max_new_tokens,\n        ...omit(args.parameters, \"max_new_tokens\")\n      } : void 0,\n      ...omit(args, [\"inputs\", \"parameters\"])\n    };\n    const raw = await request(payload, {\n      ...options,\n      taskHint: \"text-generation\"\n    });\n    const isValidOutput = typeof raw === \"object\" && \"choices\" in raw && Array.isArray(raw?.choices) && typeof raw?.model === \"string\";\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n    }\n    const completion = raw.choices[0];\n    return {\n      generated_text: completion.message.content\n    };\n  } else {\n    const res = toArray(\n      await request(args, {\n        ...options,\n        taskHint: \"text-generation\"\n      })\n    );\n    const isValidOutput = Array.isArray(res) && res.every((x) => \"generated_text\" in x && typeof x?.generated_text === \"string\");\n    if (!isValidOutput) {\n      throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n    }\n    return res?.[0];\n  }\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && /// Together.ai and Nebius do not output a system_fingerprint\n  (res.system_fingerprint === void 0 || res.system_fingerprint === null || typeof res.system_fingerprint === \"string\") && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (elem) => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && (typeof elem.end === \"number\" || typeof elem.end === \"undefined\") && (typeof elem.score === \"number\" || typeof elem.score === \"undefined\") && (typeof elem.start === \"number\" || typeof elem.start === \"undefined\")\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res[0];\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (elem) => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && typeof elem.score === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res[0];\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name2, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name2, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name2, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name2, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\n\n// src/types.ts\nvar INFERENCE_PROVIDERS = [\n  \"black-forest-labs\",\n  \"fal-ai\",\n  \"fireworks-ai\",\n  \"hf-inference\",\n  \"hyperbolic\",\n  \"nebius\",\n  \"novita\",\n  \"replicate\",\n  \"sambanova\",\n  \"together\"\n];\nexport {\n  HfInference,\n  HfInferenceEndpoint,\n  INFERENCE_PROVIDERS,\n  InferenceOutputError,\n  audioClassification,\n  audioToAudio,\n  automaticSpeechRecognition,\n  chatCompletion,\n  chatCompletionStream,\n  documentQuestionAnswering,\n  featureExtraction,\n  fillMask,\n  imageClassification,\n  imageSegmentation,\n  imageToImage,\n  imageToText,\n  objectDetection,\n  questionAnswering,\n  request,\n  sentenceSimilarity,\n  streamingRequest,\n  summarization,\n  tableQuestionAnswering,\n  tabularClassification,\n  tabularRegression,\n  textClassification,\n  textGeneration,\n  textGenerationStream,\n  textToImage,\n  textToSpeech,\n  textToVideo,\n  tokenClassification,\n  translation,\n  visualQuestionAnswering,\n  zeroShotClassification,\n  zeroShotImageClassification\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}